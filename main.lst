   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	uart_putchar
  11               	uart_putchar:
  12               	.LFB11:
  13               		.file 1 "main.c"
   1:main.c        **** #include <avr/interrupt.h>
   2:main.c        **** #include <avr/pgmspace.h>
   3:main.c        **** #include <avr/io.h>
   4:main.c        **** #include <stdio.h>
   5:main.c        **** #include <stdint.h>
   6:main.c        **** #include <math.h>
   7:main.c        **** 
   8:main.c        **** #ifndef F_CPU
   9:main.c        **** #define F_CPU 16000000UL
  10:main.c        **** #endif
  11:main.c        **** 
  12:main.c        **** #ifndef BAUD
  13:main.c        **** #define BAUD 9600
  14:main.c        **** #endif
  15:main.c        **** #include <util/setbaud.h>
  16:main.c        **** #include <util/delay.h>
  17:main.c        **** #include "lcd.h"
  18:main.c        **** 
  19:main.c        **** /*
  20:main.c        ****    The circuit:
  21:main.c        ****  * LCD RS pin to digital pin 12
  22:main.c        ****  * LCD Enable pin to digital pin 11
  23:main.c        ****  * LCD D4 pin to digital pin 6
  24:main.c        ****  * LCD D5 pin to digital pin 7
  25:main.c        ****  * LCD D6 pin to digital pin 4
  26:main.c        ****  * LCD D7 pin to digital pin 5
  27:main.c        ****  * LCD R/W pin to ground
  28:main.c        ****  * LCD VSS pin to ground
  29:main.c        ****  * LCD VCC pin to 5V
  30:main.c        ****  * 10K resistor:
  31:main.c        ****  * ends to +5V and ground
  32:main.c        ****  * wiper to LCD VO pin (pin 3)
  33:main.c        ****  *
  34:main.c        ****  * Encoder : 6,7
  35:main.c        ****  */
  36:main.c        **** 
  37:main.c        **** #define temp A0
  38:main.c        **** #define CLK 3
  39:main.c        **** #define DT 2
  40:main.c        **** #define SW 6
  41:main.c        **** 
  42:main.c        **** void adc_init(void){
  43:main.c        **** 
  44:main.c        ****     ADCSRA |= ((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0));    //16Mhz/128 = 125Khz the ADC reference clock
  45:main.c        ****     ADMUX |= (1<<REFS0); //Voltage reference from Avcc (5v)
  46:main.c        ****     ADCSRA |= (1<<ADEN); //Turn on ADC
  47:main.c        ****     ADCSRA |= (1<<ADSC); //Do an initial conversion because this one is the slowest and to ensure t
  48:main.c        **** }
  49:main.c        **** 
  50:main.c        **** uint16_t adc_read(void){
  51:main.c        ****     ADMUX &= 0xF0;                    //Clear the older channel that was read
  52:main.c        ****     ADMUX |= 0;                //Defines the new ADC channel to be read
  53:main.c        ****     ADCSRA |= (1<<ADSC);                //Starts a new conversion
  54:main.c        ****     while(ADCSRA & (1<<ADSC));            //Wait until the conversion is done
  55:main.c        ****     return ADCW;                    //Returns the ADC value of the chosen channel
  56:main.c        **** }
  57:main.c        **** 
  58:main.c        **** void uart_init(void) {
  59:main.c        ****     UBRR0H = UBRRH_VALUE;
  60:main.c        ****     UBRR0L = UBRRL_VALUE;
  61:main.c        **** 
  62:main.c        **** #if USE_2X
  63:main.c        ****     UCSR0A |= _BV(U2X0);
  64:main.c        **** #else
  65:main.c        ****     UCSR0A &= ~(_BV(U2X0));
  66:main.c        **** #endif
  67:main.c        **** 
  68:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */ 
  69:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   /* Enable RX and TX */    
  70:main.c        **** }
  71:main.c        **** 
  72:main.c        **** int uart_putchar(char c, FILE *stream) {
  14               		.loc 1 72 0
  15               	/* prologue: function */
  16               	/* frame size = 0 */
  17               	/* stack size = 0 */
  18               	.L__stack_usage = 0
  19               	.LVL0:
  20               	.L2:
  73:main.c        ****     loop_until_bit_is_set(UCSR0A, UDRE0);
  21               		.loc 1 73 0 discriminator 1
  22 0000 9091 C000 		lds r25,192
  23 0004 95FF      		sbrs r25,5
  24 0006 00C0      		rjmp .L2
  74:main.c        ****     UDR0 = c;
  25               		.loc 1 74 0
  26 0008 8093 C600 		sts 198,r24
  75:main.c        ****     return 0;
  76:main.c        **** }
  27               		.loc 1 76 0
  28 000c 80E0      		ldi r24,0
  29 000e 90E0      		ldi r25,0
  30               	.LVL1:
  31 0010 0895      		ret
  32               	.LFE11:
  34               	.global	adc_init
  36               	adc_init:
  37               	.LFB8:
  42:main.c        **** void adc_init(void){
  38               		.loc 1 42 0
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
  44:main.c        ****     ADCSRA |= ((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0));    //16Mhz/128 = 125Khz the ADC reference clock
  43               		.loc 1 44 0
  44 0012 EAE7      		ldi r30,lo8(122)
  45 0014 F0E0      		ldi r31,0
  46 0016 8081      		ld r24,Z
  47 0018 8760      		ori r24,lo8(7)
  48 001a 8083      		st Z,r24
  45:main.c        ****     ADMUX |= (1<<REFS0); //Voltage reference from Avcc (5v)
  49               		.loc 1 45 0
  50 001c ACE7      		ldi r26,lo8(124)
  51 001e B0E0      		ldi r27,0
  52 0020 8C91      		ld r24,X
  53 0022 8064      		ori r24,lo8(64)
  54 0024 8C93      		st X,r24
  46:main.c        ****     ADCSRA |= (1<<ADEN); //Turn on ADC
  55               		.loc 1 46 0
  56 0026 8081      		ld r24,Z
  57 0028 8068      		ori r24,lo8(-128)
  58 002a 8083      		st Z,r24
  47:main.c        ****     ADCSRA |= (1<<ADSC); //Do an initial conversion because this one is the slowest and to ensure t
  59               		.loc 1 47 0
  60 002c 8081      		ld r24,Z
  61 002e 8064      		ori r24,lo8(64)
  62 0030 8083      		st Z,r24
  63 0032 0895      		ret
  64               	.LFE8:
  66               	.global	adc_read
  68               	adc_read:
  69               	.LFB9:
  50:main.c        **** uint16_t adc_read(void){
  70               		.loc 1 50 0
  71               	/* prologue: function */
  72               	/* frame size = 0 */
  73               	/* stack size = 0 */
  74               	.L__stack_usage = 0
  51:main.c        ****     ADMUX &= 0xF0;                    //Clear the older channel that was read
  75               		.loc 1 51 0
  76 0034 8091 7C00 		lds r24,124
  77 0038 807F      		andi r24,lo8(-16)
  78 003a 8093 7C00 		sts 124,r24
  52:main.c        ****     ADMUX |= 0;                //Defines the new ADC channel to be read
  79               		.loc 1 52 0
  80 003e 8091 7C00 		lds r24,124
  81 0042 8093 7C00 		sts 124,r24
  53:main.c        ****     ADCSRA |= (1<<ADSC);                //Starts a new conversion
  82               		.loc 1 53 0
  83 0046 8091 7A00 		lds r24,122
  84 004a 8064      		ori r24,lo8(64)
  85 004c 8093 7A00 		sts 122,r24
  86               	.L9:
  54:main.c        ****     while(ADCSRA & (1<<ADSC));            //Wait until the conversion is done
  87               		.loc 1 54 0 discriminator 1
  88 0050 8091 7A00 		lds r24,122
  89 0054 86FD      		sbrc r24,6
  90 0056 00C0      		rjmp .L9
  55:main.c        ****     return ADCW;                    //Returns the ADC value of the chosen channel
  91               		.loc 1 55 0
  92 0058 2091 7800 		lds r18,120
  93 005c 3091 7900 		lds r19,120+1
  56:main.c        **** }
  94               		.loc 1 56 0
  95 0060 C901      		movw r24,r18
  96 0062 0895      		ret
  97               	.LFE9:
  99               	.global	uart_init
 101               	uart_init:
 102               	.LFB10:
  58:main.c        **** void uart_init(void) {
 103               		.loc 1 58 0
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
  59:main.c        ****     UBRR0H = UBRRH_VALUE;
 108               		.loc 1 59 0
 109 0064 1092 C500 		sts 197,__zero_reg__
  60:main.c        ****     UBRR0L = UBRRL_VALUE;
 110               		.loc 1 60 0
 111 0068 87E6      		ldi r24,lo8(103)
 112 006a 8093 C400 		sts 196,r24
  65:main.c        ****     UCSR0A &= ~(_BV(U2X0));
 113               		.loc 1 65 0
 114 006e E0EC      		ldi r30,lo8(-64)
 115 0070 F0E0      		ldi r31,0
 116 0072 8081      		ld r24,Z
 117 0074 8D7F      		andi r24,lo8(-3)
 118 0076 8083      		st Z,r24
  68:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */ 
 119               		.loc 1 68 0
 120 0078 86E0      		ldi r24,lo8(6)
 121 007a 8093 C200 		sts 194,r24
  69:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   /* Enable RX and TX */    
 122               		.loc 1 69 0
 123 007e 88E1      		ldi r24,lo8(24)
 124 0080 8093 C100 		sts 193,r24
 125 0084 0895      		ret
 126               	.LFE10:
 128               	.global	uart_getchar
 130               	uart_getchar:
 131               	.LFB12:
  77:main.c        **** 
  78:main.c        **** char uart_getchar(FILE *stream) {
 132               		.loc 1 78 0
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 137               	.LVL2:
 138               	.L13:
  79:main.c        ****     loop_until_bit_is_set(UCSR0A, RXC0);
 139               		.loc 1 79 0 discriminator 1
 140 0086 8091 C000 		lds r24,192
 141 008a 87FF      		sbrs r24,7
 142 008c 00C0      		rjmp .L13
  80:main.c        ****     return UDR0;
 143               		.loc 1 80 0
 144 008e 8091 C600 		lds r24,198
  81:main.c        **** }
 145               		.loc 1 81 0
 146 0092 0895      		ret
 147               	.LFE12:
 149               	.global	timer1_init
 151               	timer1_init:
 152               	.LFB13:
  82:main.c        **** 
  83:main.c        **** FILE uart_output = FDEV_SETUP_STREAM(uart_putchar,
  84:main.c        ****         NULL,
  85:main.c        ****         _FDEV_SETUP_WRITE
  86:main.c        ****         );
  87:main.c        **** 
  88:main.c        **** #define TIMER_FREQ_HZ   1
  89:main.c        **** 
  90:main.c        **** void timer1_init(void){
 153               		.loc 1 90 0
 154               	/* prologue: function */
 155               	/* frame size = 0 */
 156               	/* stack size = 0 */
 157               	.L__stack_usage = 0
  91:main.c        ****     // Init Pin PB0 Output, set to 0
  92:main.c        ****     DDRB |= (1<<DDB2);
 158               		.loc 1 92 0
 159 0094 229A      		sbi 0x4,2
  93:main.c        ****     PORTB &= ~(1<<PORTB2);
 160               		.loc 1 93 0
 161 0096 2A98      		cbi 0x5,2
  94:main.c        **** 
  95:main.c        ****     // initialize timer1
  96:main.c        ****     cli();
 162               		.loc 1 96 0
 163               	/* #APP */
 164               	 ;  96 "main.c" 1
 165 0098 F894      		cli
 166               	 ;  0 "" 2
  97:main.c        ****     TCCR1A = 0;
 167               		.loc 1 97 0
 168               	/* #NOAPP */
 169 009a A0E8      		ldi r26,lo8(-128)
 170 009c B0E0      		ldi r27,0
 171 009e 1C92      		st X,__zero_reg__
  98:main.c        ****     TCCR1B = 0;
 172               		.loc 1 98 0
 173 00a0 E1E8      		ldi r30,lo8(-127)
 174 00a2 F0E0      		ldi r31,0
 175 00a4 1082      		st Z,__zero_reg__
  99:main.c        ****     TCNT1  = 0;
 176               		.loc 1 99 0
 177 00a6 1092 8500 		sts 132+1,__zero_reg__
 178 00aa 1092 8400 		sts 132,__zero_reg__
 100:main.c        **** 
 101:main.c        ****     // Set FastPWM with OCR1A on TOP, CLEAR on Compare + Set on BOTTOM
 102:main.c        ****     // Prescaler 256
 103:main.c        ****     // Here 64 !
 104:main.c        ****     TCCR1A = _BV(COM1A1)
 179               		.loc 1 104 0
 180 00ae 83EA      		ldi r24,lo8(-93)
 181 00b0 8C93      		st X,r24
 105:main.c        ****         | _BV(COM1B1)
 106:main.c        ****         | _BV(WGM10)
 107:main.c        ****         | _BV(WGM11);
 108:main.c        **** 
 109:main.c        ****     TCCR1B = _BV(WGM12)
 182               		.loc 1 109 0
 183 00b2 8BE1      		ldi r24,lo8(27)
 184 00b4 8083      		st Z,r24
 110:main.c        ****         | _BV(WGM13)
 111:main.c        ****         | _BV(CS11)
 112:main.c        ****         | _BV(CS10);
 113:main.c        **** 
 114:main.c        ****     OCR1B = 0;//156;//10*3125/100;
 185               		.loc 1 114 0
 186 00b6 1092 8B00 		sts 138+1,__zero_reg__
 187 00ba 1092 8A00 		sts 138,__zero_reg__
 115:main.c        ****     OCR1A = 3125;
 188               		.loc 1 115 0
 189 00be 85E3      		ldi r24,lo8(53)
 190 00c0 9CE0      		ldi r25,lo8(12)
 191 00c2 9093 8900 		sts 136+1,r25
 192 00c6 8093 8800 		sts 136,r24
 116:main.c        ****     sei();             // enable all interrupts
 193               		.loc 1 116 0
 194               	/* #APP */
 195               	 ;  116 "main.c" 1
 196 00ca 7894      		sei
 197               	 ;  0 "" 2
 198               	/* #NOAPP */
 199 00cc 0895      		ret
 200               	.LFE13:
 202               	.global	timer0_init
 204               	timer0_init:
 205               	.LFB14:
 117:main.c        **** }
 118:main.c        **** 
 119:main.c        **** long int sec;
 120:main.c        **** void timer0_init(void){
 206               		.loc 1 120 0
 207               	/* prologue: function */
 208               	/* frame size = 0 */
 209               	/* stack size = 0 */
 210               	.L__stack_usage = 0
 121:main.c        ****     cli();
 211               		.loc 1 121 0
 212               	/* #APP */
 213               	 ;  121 "main.c" 1
 214 00ce F894      		cli
 215               	 ;  0 "" 2
 122:main.c        **** 
 123:main.c        ****     TCCR0A = 0;
 216               		.loc 1 123 0
 217               	/* #NOAPP */
 218 00d0 14BC      		out 0x24,__zero_reg__
 124:main.c        ****     TCCR0B = 0;
 219               		.loc 1 124 0
 220 00d2 15BC      		out 0x25,__zero_reg__
 125:main.c        ****     TCNT0  = 0;
 221               		.loc 1 125 0
 222 00d4 16BC      		out 0x26,__zero_reg__
 126:main.c        **** 
 127:main.c        ****     // Presc 1024
 128:main.c        ****     TCCR0B |= _BV(CS02) | _BV(CS00);
 223               		.loc 1 128 0
 224 00d6 85B5      		in r24,0x25
 225 00d8 8560      		ori r24,lo8(5)
 226 00da 85BD      		out 0x25,r24
 129:main.c        **** 
 130:main.c        ****     TIMSK0 |= _BV(TOIE0);
 227               		.loc 1 130 0
 228 00dc EEE6      		ldi r30,lo8(110)
 229 00de F0E0      		ldi r31,0
 230 00e0 8081      		ld r24,Z
 231 00e2 8160      		ori r24,lo8(1)
 232 00e4 8083      		st Z,r24
 131:main.c        ****     sei();
 233               		.loc 1 131 0
 234               	/* #APP */
 235               	 ;  131 "main.c" 1
 236 00e6 7894      		sei
 237               	 ;  0 "" 2
 238               	/* #NOAPP */
 239 00e8 0895      		ret
 240               	.LFE14:
 242               	.global	__vector_16
 244               	__vector_16:
 245               	.LFB15:
 132:main.c        **** }
 133:main.c        **** 
 134:main.c        **** ISR(TIMER0_OVF_vect)
 135:main.c        **** {
 246               		.loc 1 135 0
 247 00ea 1F92      		push r1
 248               	.LCFI0:
 249 00ec 0F92      		push r0
 250               	.LCFI1:
 251 00ee 0FB6      		in r0,__SREG__
 252 00f0 0F92      		push r0
 253 00f2 1124      		clr __zero_reg__
 254 00f4 8F93      		push r24
 255               	.LCFI2:
 256 00f6 9F93      		push r25
 257               	.LCFI3:
 258 00f8 AF93      		push r26
 259               	.LCFI4:
 260 00fa BF93      		push r27
 261               	.LCFI5:
 262               	/* prologue: Signal */
 263               	/* frame size = 0 */
 264               	/* stack size = 7 */
 265               	.L__stack_usage = 7
 136:main.c        ****     sec+=1;//(1024.f/16E6);
 266               		.loc 1 136 0
 267 00fc 8091 0000 		lds r24,sec
 268 0100 9091 0000 		lds r25,sec+1
 269 0104 A091 0000 		lds r26,sec+2
 270 0108 B091 0000 		lds r27,sec+3
 271 010c 0196      		adiw r24,1
 272 010e A11D      		adc r26,__zero_reg__
 273 0110 B11D      		adc r27,__zero_reg__
 274 0112 8093 0000 		sts sec,r24
 275 0116 9093 0000 		sts sec+1,r25
 276 011a A093 0000 		sts sec+2,r26
 277 011e B093 0000 		sts sec+3,r27
 278               	/* epilogue start */
 137:main.c        **** } 
 279               		.loc 1 137 0
 280 0122 BF91      		pop r27
 281 0124 AF91      		pop r26
 282 0126 9F91      		pop r25
 283 0128 8F91      		pop r24
 284 012a 0F90      		pop r0
 285 012c 0FBE      		out __SREG__,r0
 286 012e 0F90      		pop r0
 287 0130 1F90      		pop r1
 288 0132 1895      		reti
 289               	.LFE15:
 291               	.global	__floatsisf
 292               	.global	__mulsf3
 293               	.global	seconds
 295               	seconds:
 296               	.LFB16:
 138:main.c        **** 
 139:main.c        **** float seconds(void){
 297               		.loc 1 139 0
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 0 */
 301               	.L__stack_usage = 0
 140:main.c        ****     float result;
 141:main.c        ****     cli();
 302               		.loc 1 141 0
 303               	/* #APP */
 304               	 ;  141 "main.c" 1
 305 0134 F894      		cli
 306               	 ;  0 "" 2
 142:main.c        ****     result = sec*(255.f*1024.f/16E6);
 307               		.loc 1 142 0
 308               	/* #NOAPP */
 309 0136 6091 0000 		lds r22,sec
 310 013a 7091 0000 		lds r23,sec+1
 311 013e 8091 0000 		lds r24,sec+2
 312 0142 9091 0000 		lds r25,sec+3
 313 0146 0E94 0000 		call __floatsisf
 314               	.LVL3:
 315 014a 25E8      		ldi r18,lo8(-123)
 316 014c 31EB      		ldi r19,lo8(-79)
 317 014e 45E8      		ldi r20,lo8(-123)
 318 0150 5CE3      		ldi r21,lo8(60)
 319 0152 0E94 0000 		call __mulsf3
 320               	.LVL4:
 143:main.c        ****     sei();
 321               		.loc 1 143 0
 322               	/* #APP */
 323               	 ;  143 "main.c" 1
 324 0156 7894      		sei
 325               	 ;  0 "" 2
 144:main.c        ****     return result;
 145:main.c        **** }
 326               		.loc 1 145 0
 327               	/* #NOAPP */
 328 0158 0895      		ret
 329               	.LFE16:
 331               	.global	millis
 333               	millis:
 334               	.LFB17:
 146:main.c        **** 
 147:main.c        **** float millis(void){// OVERFLOW in 3,4E38 ms
 335               		.loc 1 147 0
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 148:main.c        ****     float result;
 149:main.c        ****     cli();
 340               		.loc 1 149 0
 341               	/* #APP */
 342               	 ;  149 "main.c" 1
 343 015a F894      		cli
 344               	 ;  0 "" 2
 150:main.c        ****     result = sec*(255.f*1024.f/(16E6))*1000.f;
 345               		.loc 1 150 0
 346               	/* #NOAPP */
 347 015c 6091 0000 		lds r22,sec
 348 0160 7091 0000 		lds r23,sec+1
 349 0164 8091 0000 		lds r24,sec+2
 350 0168 9091 0000 		lds r25,sec+3
 351 016c 0E94 0000 		call __floatsisf
 352               	.LVL5:
 353 0170 25E8      		ldi r18,lo8(-123)
 354 0172 31EB      		ldi r19,lo8(-79)
 355 0174 45E8      		ldi r20,lo8(-123)
 356 0176 5CE3      		ldi r21,lo8(60)
 357 0178 0E94 0000 		call __mulsf3
 358               	.LVL6:
 359 017c 20E0      		ldi r18,0
 360 017e 30E0      		ldi r19,0
 361 0180 4AE7      		ldi r20,lo8(122)
 362 0182 54E4      		ldi r21,lo8(68)
 363 0184 0E94 0000 		call __mulsf3
 364               	.LVL7:
 151:main.c        ****     sei();
 365               		.loc 1 151 0
 366               	/* #APP */
 367               	 ;  151 "main.c" 1
 368 0188 7894      		sei
 369               	 ;  0 "" 2
 152:main.c        ****     return result;
 153:main.c        **** }
 370               		.loc 1 153 0
 371               	/* #NOAPP */
 372 018a 0895      		ret
 373               	.LFE17:
 375               	.global	__fixsfsi
 376               	.global	set_temp
 378               	set_temp:
 379               	.LFB18:
 154:main.c        **** 
 155:main.c        **** #define TEMP_MAX 480
 156:main.c        **** #define DEFAULT_TEMP 220
 157:main.c        **** float old_error,dt,new_error,derivative,integral,KP,KI,KD,command;
 158:main.c        **** long new_time,old_time;
 159:main.c        **** 
 160:main.c        **** void set_temp(float temp){
 380               		.loc 1 160 0
 381               	.LVL8:
 382               	/* prologue: function */
 383               	/* frame size = 0 */
 384               	/* stack size = 0 */
 385               	.L__stack_usage = 0
 161:main.c        ****     uint16_t duty_cycle;
 162:main.c        ****     int duty_cycle_int = temp * (TEMP_MAX / 100.0f);
 386               		.loc 1 162 0
 387 018c 2AE9      		ldi r18,lo8(-102)
 388 018e 39E9      		ldi r19,lo8(-103)
 389 0190 49E9      		ldi r20,lo8(-103)
 390 0192 50E4      		ldi r21,lo8(64)
 391 0194 0E94 0000 		call __mulsf3
 392               	.LVL9:
 393 0198 0E94 0000 		call __fixsfsi
 394               	.LVL10:
 163:main.c        ****     // FIXME : Dutycycle not in pourcent but model was made as this
 164:main.c        ****     //int duty_cycle_int = (int)(temp * (100/TEMP_MAX));
 165:main.c        ****     duty_cycle = (uint16_t)(duty_cycle_int) * 31;
 395               		.loc 1 165 0
 396 019c 2FE1      		ldi r18,lo8(31)
 397 019e 269F      		mul r18,r22
 398 01a0 C001      		movw r24,r0
 399 01a2 279F      		mul r18,r23
 400 01a4 900D      		add r25,r0
 401 01a6 1124      		clr __zero_reg__
 402               	.LVL11:
 166:main.c        ****     if(duty_cycle>=2500) duty_cycle = 2500;
 403               		.loc 1 166 0
 404 01a8 843C      		cpi r24,-60
 405 01aa 29E0      		ldi r18,9
 406 01ac 9207      		cpc r25,r18
 407 01ae 00F0      		brlo .L21
 408 01b0 84EC      		ldi r24,lo8(-60)
 409 01b2 99E0      		ldi r25,lo8(9)
 410               	.LVL12:
 411               	.L21:
 167:main.c        ****     if(duty_cycle<0)    duty_cycle = 0;
 168:main.c        **** 
 169:main.c        ****     cli();
 412               		.loc 1 169 0
 413               	/* #APP */
 414               	 ;  169 "main.c" 1
 415 01b4 F894      		cli
 416               	 ;  0 "" 2
 170:main.c        ****     OCR1B = duty_cycle;
 417               		.loc 1 170 0
 418               	/* #NOAPP */
 419 01b6 9093 8B00 		sts 138+1,r25
 420 01ba 8093 8A00 		sts 138,r24
 171:main.c        ****     sei();
 421               		.loc 1 171 0
 422               	/* #APP */
 423               	 ;  171 "main.c" 1
 424 01be 7894      		sei
 425               	 ;  0 "" 2
 426               	/* #NOAPP */
 427 01c0 0895      		ret
 428               	.LFE18:
 430               	.global	__floatunsisf
 431               	.global	__gtsf2
 432               	.global	__subsf3
 433               	.global	__addsf3
 434               	.global	__divsf3
 435               	.global	get_temp
 437               	get_temp:
 438               	.LFB19:
 172:main.c        **** }
 173:main.c        **** 
 174:main.c        **** float get_temp(void){
 439               		.loc 1 174 0
 440 01c2 8F92      		push r8
 441               	.LCFI6:
 442 01c4 9F92      		push r9
 443               	.LCFI7:
 444 01c6 AF92      		push r10
 445               	.LCFI8:
 446 01c8 BF92      		push r11
 447               	.LCFI9:
 448 01ca EF92      		push r14
 449               	.LCFI10:
 450 01cc FF92      		push r15
 451               	.LCFI11:
 452 01ce 0F93      		push r16
 453               	.LCFI12:
 454 01d0 1F93      		push r17
 455               	.LCFI13:
 456 01d2 CF93      		push r28
 457               	.LCFI14:
 458 01d4 DF93      		push r29
 459               	.LCFI15:
 460               	/* prologue: function */
 461               	/* frame size = 0 */
 462               	/* stack size = 10 */
 463               	.L__stack_usage = 10
 464               	.LVL13:
 175:main.c        ****     int i;
 176:main.c        ****     static float lpf_temp;
 177:main.c        ****     float avg_temp = 0.0;
 178:main.c        **** #define AVG_SAMPLE 300
 179:main.c        ****     if(adc_read()*(5.0f/1024.0f) > 4){
 465               		.loc 1 179 0
 466 01d6 0E94 0000 		call adc_read
 467               	.LVL14:
 468 01da BC01      		movw r22,r24
 469 01dc 80E0      		ldi r24,0
 470 01de 90E0      		ldi r25,0
 471 01e0 0E94 0000 		call __floatunsisf
 472               	.LVL15:
 473 01e4 20E0      		ldi r18,0
 474 01e6 30E0      		ldi r19,0
 475 01e8 40EA      		ldi r20,lo8(-96)
 476 01ea 5BE3      		ldi r21,lo8(59)
 477 01ec 0E94 0000 		call __mulsf3
 478               	.LVL16:
 479 01f0 20E0      		ldi r18,0
 480 01f2 30E0      		ldi r19,0
 481 01f4 40E8      		ldi r20,lo8(-128)
 482 01f6 50E4      		ldi r21,lo8(64)
 483 01f8 0E94 0000 		call __gtsf2
 484               	.LVL17:
 485 01fc 1816      		cp __zero_reg__,r24
 486 01fe 04F4      		brge .+2
 487 0200 00C0      		rjmp .L26
 488 0202 CCE2      		ldi r28,lo8(44)
 489 0204 D1E0      		ldi r29,lo8(1)
 490 0206 E12C      		mov r14,__zero_reg__
 491 0208 F12C      		mov r15,__zero_reg__
 492 020a 00E0      		ldi r16,0
 493 020c 10E0      		ldi r17,0
 494               	.LVL18:
 495               	.L25:
 180:main.c        ****         return -1.0f;
 181:main.c        ****     }
 182:main.c        ****     for(i=0;i<AVG_SAMPLE;i++){
 183:main.c        ****         avg_temp += 600*(5.0f/1024.0f)*adc_read() - 100; //0.5V => 200°C
 496               		.loc 1 183 0 discriminator 2
 497 020e 0E94 0000 		call adc_read
 498               	.LVL19:
 499 0212 BC01      		movw r22,r24
 500 0214 80E0      		ldi r24,0
 501 0216 90E0      		ldi r25,0
 502 0218 0E94 0000 		call __floatunsisf
 503               	.LVL20:
 504 021c 20E0      		ldi r18,0
 505 021e 30E8      		ldi r19,lo8(-128)
 506 0220 4BE3      		ldi r20,lo8(59)
 507 0222 50E4      		ldi r21,lo8(64)
 508 0224 0E94 0000 		call __mulsf3
 509               	.LVL21:
 510 0228 20E0      		ldi r18,0
 511 022a 30E0      		ldi r19,0
 512 022c 48EC      		ldi r20,lo8(-56)
 513 022e 52E4      		ldi r21,lo8(66)
 514 0230 0E94 0000 		call __subsf3
 515               	.LVL22:
 516 0234 9B01      		movw r18,r22
 517 0236 AC01      		movw r20,r24
 518 0238 6E2D      		mov r22,r14
 519 023a 7F2D      		mov r23,r15
 520 023c 802F      		mov r24,r16
 521 023e 912F      		mov r25,r17
 522 0240 0E94 0000 		call __addsf3
 523               	.LVL23:
 524 0244 7B01      		movw r14,r22
 525 0246 8C01      		movw r16,r24
 526               	.LVL24:
 527 0248 2197      		sbiw r28,1
 182:main.c        ****     for(i=0;i<AVG_SAMPLE;i++){
 528               		.loc 1 182 0 discriminator 2
 529 024a 01F4      		brne .L25
 184:main.c        ****     }
 185:main.c        ****     avg_temp = avg_temp/AVG_SAMPLE;
 530               		.loc 1 185 0
 531 024c 20E0      		ldi r18,0
 532 024e 30E0      		ldi r19,0
 533 0250 46E9      		ldi r20,lo8(-106)
 534 0252 53E4      		ldi r21,lo8(67)
 535 0254 7F2D      		mov r23,r15
 536 0256 912F      		mov r25,r17
 537 0258 0E94 0000 		call __divsf3
 538               	.LVL25:
 539 025c 8B01      		movw r16,r22
 540 025e D82F      		mov r29,r24
 541 0260 C92F      		mov r28,r25
 542               	.LVL26:
 186:main.c        **** #define alpha 0.99f
 187:main.c        ****     lpf_temp = lpf_temp*alpha + (1.0-alpha)*avg_temp;
 543               		.loc 1 187 0
 544 0262 24EA      		ldi r18,lo8(-92)
 545 0264 30E7      		ldi r19,lo8(112)
 546 0266 4DE7      		ldi r20,lo8(125)
 547 0268 5FE3      		ldi r21,lo8(63)
 548 026a 6091 0000 		lds r22,lpf_temp.1903
 549 026e 7091 0000 		lds r23,lpf_temp.1903+1
 550 0272 8091 0000 		lds r24,lpf_temp.1903+2
 551 0276 9091 0000 		lds r25,lpf_temp.1903+3
 552 027a 0E94 0000 		call __mulsf3
 553               	.LVL27:
 554 027e 4B01      		movw r8,r22
 555 0280 5C01      		movw r10,r24
 556 0282 20E0      		ldi r18,0
 557 0284 37ED      		ldi r19,lo8(-41)
 558 0286 43E2      		ldi r20,lo8(35)
 559 0288 5CE3      		ldi r21,lo8(60)
 560 028a FE01      		movw r30,r28
 561 028c 602F      		mov r22,r16
 562 028e 712F      		mov r23,r17
 563 0290 8F2F      		mov r24,r31
 564 0292 9E2F      		mov r25,r30
 565 0294 0E94 0000 		call __mulsf3
 566               	.LVL28:
 567 0298 9B01      		movw r18,r22
 568 029a AC01      		movw r20,r24
 569 029c C501      		movw r24,r10
 570 029e B401      		movw r22,r8
 571 02a0 0E94 0000 		call __addsf3
 572               	.LVL29:
 573 02a4 6093 0000 		sts lpf_temp.1903,r22
 574 02a8 7093 0000 		sts lpf_temp.1903+1,r23
 575 02ac 8093 0000 		sts lpf_temp.1903+2,r24
 576 02b0 9093 0000 		sts lpf_temp.1903+3,r25
 188:main.c        ****     return ((float)avg_temp);
 577               		.loc 1 188 0
 578 02b4 00C0      		rjmp .L24
 579               	.LVL30:
 580               	.L26:
 180:main.c        ****         return -1.0f;
 581               		.loc 1 180 0
 582 02b6 00E0      		ldi r16,0
 583 02b8 10E0      		ldi r17,0
 584 02ba D0E8      		ldi r29,lo8(-128)
 585 02bc CFEB      		ldi r28,lo8(-65)
 586               	.LVL31:
 587               	.L24:
 189:main.c        **** }
 588               		.loc 1 189 0
 589 02be 9E01      		movw r18,r28
 590 02c0 602F      		mov r22,r16
 591 02c2 712F      		mov r23,r17
 592 02c4 832F      		mov r24,r19
 593 02c6 9C2F      		mov r25,r28
 594               	/* epilogue start */
 595 02c8 DF91      		pop r29
 596 02ca CF91      		pop r28
 597 02cc 1F91      		pop r17
 598 02ce 0F91      		pop r16
 599 02d0 FF90      		pop r15
 600 02d2 EF90      		pop r14
 601 02d4 BF90      		pop r11
 602 02d6 AF90      		pop r10
 603 02d8 9F90      		pop r9
 604 02da 8F90      		pop r8
 605 02dc 0895      		ret
 606               	.LFE19:
 608               	.global	encoder_init
 610               	encoder_init:
 611               	.LFB20:
 190:main.c        **** 
 191:main.c        **** 
 192:main.c        **** enum e_state {Update_Consigne,
 193:main.c        ****     Process_Commmand,
 194:main.c        ****     Send_Log};
 195:main.c        **** enum e_state state = Update_Consigne;
 196:main.c        **** uint8_t flag_change_consigne = 0;
 197:main.c        **** 
 198:main.c        **** int counts = 0;
 199:main.c        **** void encoder_init(void){
 612               		.loc 1 199 0
 613               	/* prologue: function */
 614               	/* frame size = 0 */
 615               	/* stack size = 0 */
 616               	.L__stack_usage = 0
 200:main.c        ****     // DT   2
 201:main.c        ****     // CK   3
 202:main.c        ****     // PUSH 6
 203:main.c        **** 
 204:main.c        ****     DDRD &= ~(1<<DDD2);
 617               		.loc 1 204 0
 618 02de 5298      		cbi 0xa,2
 205:main.c        ****     DDRD &= ~(1<<DDD3);
 619               		.loc 1 205 0
 620 02e0 5398      		cbi 0xa,3
 206:main.c        ****     DDRD &= ~(1<<DDD6);
 621               		.loc 1 206 0
 622 02e2 5698      		cbi 0xa,6
 207:main.c        **** 
 208:main.c        ****     PORTD |= (1<<PORTD2);
 623               		.loc 1 208 0
 624 02e4 5A9A      		sbi 0xb,2
 209:main.c        ****     PORTD |= (1<<PORTD3);
 625               		.loc 1 209 0
 626 02e6 5B9A      		sbi 0xb,3
 210:main.c        ****     PORTD |= (1<<PORTD6);
 627               		.loc 1 210 0
 628 02e8 5E9A      		sbi 0xb,6
 211:main.c        ****     counts = 0;
 629               		.loc 1 211 0
 630 02ea 1092 0000 		sts counts+1,__zero_reg__
 631 02ee 1092 0000 		sts counts,__zero_reg__
 212:main.c        **** 
 213:main.c        ****     // Set Exti
 214:main.c        ****     // Trigger INT1 falling edge
 215:main.c        ****     EICRA |= (1<<ISC11);
 632               		.loc 1 215 0
 633 02f2 E9E6      		ldi r30,lo8(105)
 634 02f4 F0E0      		ldi r31,0
 635 02f6 8081      		ld r24,Z
 636 02f8 8860      		ori r24,lo8(8)
 637 02fa 8083      		st Z,r24
 216:main.c        ****     // Enable INT1
 217:main.c        ****     EIMSK |= (1<<INT1);
 638               		.loc 1 217 0
 639 02fc E99A      		sbi 0x1d,1
 640 02fe 0895      		ret
 641               	.LFE20:
 643               	.global	enc_switch_state
 645               	enc_switch_state:
 646               	.LFB21:
 218:main.c        **** }
 219:main.c        **** 
 220:main.c        **** // Return 1 if pressed
 221:main.c        **** uint8_t enc_switch_state(void){
 647               		.loc 1 221 0
 648               	/* prologue: function */
 649               	/* frame size = 0 */
 650               	/* stack size = 0 */
 651               	.L__stack_usage = 0
 222:main.c        ****     return !(PIND&(1<<PIND6)); 
 652               		.loc 1 222 0
 653 0300 89B1      		in r24,0x9
 654 0302 86FB      		bst r24,6
 655 0304 8827      		clr r24
 656 0306 80F9      		bld r24,0
 223:main.c        **** }
 657               		.loc 1 223 0
 658 0308 91E0      		ldi r25,lo8(1)
 659 030a 8927      		eor r24,r25
 660 030c 0895      		ret
 661               	.LFE21:
 663               	.global	__vector_2
 665               	__vector_2:
 666               	.LFB22:
 224:main.c        **** ISR (INT1_vect){
 667               		.loc 1 224 0
 668 030e 1F92      		push r1
 669               	.LCFI16:
 670 0310 0F92      		push r0
 671               	.LCFI17:
 672 0312 0FB6      		in r0,__SREG__
 673 0314 0F92      		push r0
 674 0316 1124      		clr __zero_reg__
 675 0318 8F93      		push r24
 676               	.LCFI18:
 677 031a 9F93      		push r25
 678               	.LCFI19:
 679               	/* prologue: Signal */
 680               	/* frame size = 0 */
 681               	/* stack size = 5 */
 682               	.L__stack_usage = 5
 225:main.c        ****     // A
 226:main.c        ****     if(flag_change_consigne){
 683               		.loc 1 226 0
 684 031c 8091 0000 		lds r24,flag_change_consigne
 685 0320 8823      		tst r24
 686 0322 01F0      		breq .L30
 687 0324 8091 0000 		lds r24,counts
 688 0328 9091 0000 		lds r25,counts+1
 227:main.c        ****         if(PIND&(1<<PIND2)){
 689               		.loc 1 227 0
 690 032c 4A9B      		sbis 0x9,2
 691 032e 00C0      		rjmp .L32
 228:main.c        ****             counts ++;
 692               		.loc 1 228 0
 693 0330 0196      		adiw r24,1
 694 0332 00C0      		rjmp .L36
 695               	.L32:
 229:main.c        ****         }
 230:main.c        ****         else{
 231:main.c        ****             counts --;
 696               		.loc 1 231 0
 697 0334 0197      		sbiw r24,1
 698               	.L36:
 699 0336 9093 0000 		sts counts+1,r25
 700 033a 8093 0000 		sts counts,r24
 701               	.L30:
 702               	/* epilogue start */
 232:main.c        **** 
 233:main.c        ****         }
 234:main.c        ****     }
 235:main.c        **** }
 703               		.loc 1 235 0
 704 033e 9F91      		pop r25
 705 0340 8F91      		pop r24
 706 0342 0F90      		pop r0
 707 0344 0FBE      		out __SREG__,r0
 708 0346 0F90      		pop r0
 709 0348 1F90      		pop r1
 710 034a 1895      		reti
 711               	.LFE22:
 713               	.global	get_counts
 715               	get_counts:
 716               	.LFB23:
 236:main.c        **** 
 237:main.c        **** int get_counts(void){
 717               		.loc 1 237 0
 718               	/* prologue: function */
 719               	/* frame size = 0 */
 720               	/* stack size = 0 */
 721               	.L__stack_usage = 0
 238:main.c        ****     int result;
 239:main.c        ****     cli();
 722               		.loc 1 239 0
 723               	/* #APP */
 724               	 ;  239 "main.c" 1
 725 034c F894      		cli
 726               	 ;  0 "" 2
 240:main.c        ****     result = counts;
 727               		.loc 1 240 0
 728               	/* #NOAPP */
 729 034e 8091 0000 		lds r24,counts
 730 0352 9091 0000 		lds r25,counts+1
 731               	.LVL32:
 241:main.c        ****     sei();
 732               		.loc 1 241 0
 733               	/* #APP */
 734               	 ;  241 "main.c" 1
 735 0356 7894      		sei
 736               	 ;  0 "" 2
 242:main.c        ****     return result;
 243:main.c        **** }
 737               		.loc 1 243 0
 738               	/* #NOAPP */
 739 0358 0895      		ret
 740               	.LFE23:
 742               	.global	update_screen
 744               	update_screen:
 745               	.LFB24:
 244:main.c        **** 
 245:main.c        **** 
 246:main.c        **** uint8_t line1[]   = "Starting up ...";
 247:main.c        **** uint8_t line2[]   = "               ";
 248:main.c        **** void update_screen(void){
 746               		.loc 1 248 0
 747               	/* prologue: function */
 748               	/* frame size = 0 */
 749               	/* stack size = 0 */
 750               	.L__stack_usage = 0
 249:main.c        ****     lcd_write_instruction_4d(lcd_Home);
 751               		.loc 1 249 0
 752 035a 82E0      		ldi r24,lo8(2)
 753 035c 0E94 0000 		call lcd_write_instruction_4d
 754               	.LVL33:
 755               	.LBB8:
 756               	.LBB9:
 757               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 758               		.loc 2 246 0
 759 0360 8FE3      		ldi r24,lo8(319)
 760 0362 91E0      		ldi r25,hi8(319)
 761 0364 0197      		1: sbiw r24,1
 762 0366 01F4      		brne 1b
 763 0368 00C0      		rjmp .
 764 036a 0000      		nop
 765               	.LBE9:
 766               	.LBE8:
 250:main.c        ****     _delay_us(80);                                  // 40 uS delay (min)
 251:main.c        ****     lcd_write_string_4d(line1);
 767               		.loc 1 251 0
 768 036c 80E0      		ldi r24,lo8(line1)
 769 036e 90E0      		ldi r25,hi8(line1)
 770 0370 0E94 0000 		call lcd_write_string_4d
 771               	.LVL34:
 252:main.c        ****     new_line(2);
 772               		.loc 1 252 0
 773 0374 82E0      		ldi r24,lo8(2)
 774 0376 0E94 0000 		call new_line
 775               	.LVL35:
 253:main.c        ****     lcd_write_string_4d(line2);
 776               		.loc 1 253 0
 777 037a 80E0      		ldi r24,lo8(line2)
 778 037c 90E0      		ldi r25,hi8(line2)
 779 037e 0E94 0000 		call lcd_write_string_4d
 780               	.LVL36:
 254:main.c        ****     new_line(1);
 781               		.loc 1 254 0
 782 0382 81E0      		ldi r24,lo8(1)
 783 0384 0C94 0000 		jmp new_line
 784               	.LVL37:
 785               	.LFE24:
 787               		.section	.rodata.str1.1,"aMS",@progbits,1
 788               	.LC0:
 789 0000 4465 6275 		.string	"Debut\r"
 789      740D 00
 790               	.LC1:
 791 0007 5365 7420 		.string	"Set : %i C         "
 791      3A20 2569 
 791      2043 2020 
 791      2020 2020 
 791      2020 2000 
 792               	.LC2:
 793 001b 5B25 735D 		.string	"[%s]\n\r"
 793      0A0D 00
 794               	.LC3:
 795 0022 5465 6D70 		.string	"Temp %i C         "
 795      2025 6920 
 795      4320 2020 
 795      2020 2020 
 795      2020 00
 796               	.LC4:
 797 0035 2025 6920 		.string	" %i C             "
 797      4320 2020 
 797      2020 2020 
 797      2020 2020 
 797      2020 00
 798               	.global	__ltsf2
 799               	.LC5:
 800 0048 4E6F 2049 		.string	"No Iron               "
 800      726F 6E20 
 800      2020 2020 
 800      2020 2020 
 800      2020 2020 
 801               	.global	__gesf2
 802               		.section	.text.startup,"ax",@progbits
 803               	.global	main
 805               	main:
 806               	.LFB25:
 255:main.c        **** 
 256:main.c        **** }
 257:main.c        **** 
 258:main.c        **** uint16_t Consigne = DEFAULT_TEMP;
 259:main.c        **** long last_display_update_ms = 0;
 260:main.c        **** 
 261:main.c        **** long time;
 262:main.c        **** 
 263:main.c        **** int main(void)
 264:main.c        **** {
 807               		.loc 1 264 0
 808 0000 CF93      		push r28
 809               	.LCFI20:
 810 0002 DF93      		push r29
 811               	.LCFI21:
 812 0004 1F92      		push __zero_reg__
 813               	.LCFI22:
 814 0006 CDB7      		in r28,__SP_L__
 815 0008 DEB7      		in r29,__SP_H__
 816               	.LCFI23:
 817               	/* prologue: function */
 818               	/* frame size = 1 */
 819               	/* stack size = 3 */
 820               	.L__stack_usage = 3
 265:main.c        ****     //long newPosition;
 266:main.c        ****     //long oldPosition = -999;
 267:main.c        **** 
 268:main.c        **** 
 269:main.c        ****     uart_init();
 821               		.loc 1 269 0
 822 000a 0E94 0000 		call uart_init
 823               	.LVL38:
 270:main.c        **** 
 271:main.c        ****     sei();
 824               		.loc 1 271 0
 825               	/* #APP */
 826               	 ;  271 "main.c" 1
 827 000e 7894      		sei
 828               	 ;  0 "" 2
 272:main.c        **** 
 273:main.c        ****     stdout = &uart_output;
 829               		.loc 1 273 0
 830               	/* #NOAPP */
 831 0010 80E0      		ldi r24,lo8(uart_output)
 832 0012 90E0      		ldi r25,hi8(uart_output)
 833 0014 9093 0000 		sts __iob+2+1,r25
 834 0018 8093 0000 		sts __iob+2,r24
 274:main.c        **** 
 275:main.c        ****     timer1_init();
 835               		.loc 1 275 0
 836 001c 0E94 0000 		call timer1_init
 837               	.LVL39:
 276:main.c        ****     timer0_init();
 838               		.loc 1 276 0
 839 0020 0E94 0000 		call timer0_init
 840               	.LVL40:
 277:main.c        ****     lcd_init_4d();
 841               		.loc 1 277 0
 842 0024 0E94 0000 		call lcd_init_4d
 843               	.LVL41:
 278:main.c        **** 
 279:main.c        ****     //lcd_write_string_4d(line1);
 280:main.c        ****     printf("Debut\r\n");
 844               		.loc 1 280 0
 845 0028 80E0      		ldi r24,lo8(.LC0)
 846 002a 90E0      		ldi r25,hi8(.LC0)
 847 002c 0E94 0000 		call puts
 848               	.LVL42:
 281:main.c        **** 
 282:main.c        **** 
 283:main.c        **** 
 284:main.c        ****     encoder_init();
 849               		.loc 1 284 0
 850 0030 0E94 0000 		call encoder_init
 851               	.LVL43:
 285:main.c        ****     adc_init();
 852               		.loc 1 285 0
 853 0034 0E94 0000 		call adc_init
 854               	.LVL44:
 286:main.c        **** 
 287:main.c        ****     float tempp;
 288:main.c        ****     Consigne = DEFAULT_TEMP;
 855               		.loc 1 288 0
 856 0038 8CED      		ldi r24,lo8(-36)
 857 003a 90E0      		ldi r25,0
 858 003c 9093 0000 		sts Consigne+1,r25
 859 0040 8093 0000 		sts Consigne,r24
 860               	.LVL45:
 289:main.c        ****     uint8_t flag_no_iron = 0;
 290:main.c        **** 
 291:main.c        ****     for (;;) {
 292:main.c        ****         update_screen();
 293:main.c        **** 
 294:main.c        ****         switch(state){
 295:main.c        ****             case Update_Consigne:
 296:main.c        ****                 set_temp(0.f);
 297:main.c        ****                 Consigne = DEFAULT_TEMP + (get_counts()>>2);
 298:main.c        **** 
 299:main.c        ****                 snprintf((char*)line1,16,"Set : %i C         ",Consigne);
 861               		.loc 1 299 0
 862 0044 40E0      		ldi r20,lo8(.LC1)
 863 0046 242E      		mov r2,r20
 864 0048 40E0      		ldi r20,hi8(.LC1)
 865 004a 342E      		mov r3,r20
 866 004c 10E1      		ldi r17,lo8(16)
 300:main.c        ****                 if(enc_switch_state()){
 301:main.c        **** 
 302:main.c        ****                     while(enc_switch_state());
 303:main.c        ****                     _delay_ms(500);
 304:main.c        ****                     while(!enc_switch_state()){
 305:main.c        ****                         flag_change_consigne = 1;
 867               		.loc 1 305 0
 868 004e 01E0      		ldi r16,lo8(1)
 869               	.LVL46:
 870               	.L63:
 292:main.c        ****         update_screen();
 871               		.loc 1 292 0
 872 0050 0E94 0000 		call update_screen
 873               	.LVL47:
 294:main.c        ****         switch(state){
 874               		.loc 1 294 0
 875 0054 8091 0000 		lds r24,state
 876 0058 8130      		cpi r24,lo8(1)
 877 005a 01F4      		brne .+2
 878 005c 00C0      		rjmp .L43
 879 005e 00F0      		brlo .L42
 880 0060 8230      		cpi r24,lo8(2)
 881 0062 01F4      		brne .L63
 882 0064 00C0      		rjmp .L44
 883               	.L42:
 296:main.c        ****                 set_temp(0.f);
 884               		.loc 1 296 0
 885 0066 60E0      		ldi r22,0
 886 0068 70E0      		ldi r23,0
 887 006a CB01      		movw r24,r22
 888 006c 0E94 0000 		call set_temp
 889               	.LVL48:
 297:main.c        ****                 Consigne = DEFAULT_TEMP + (get_counts()>>2);
 890               		.loc 1 297 0
 891 0070 0E94 0000 		call get_counts
 892               	.LVL49:
 893 0074 9595      		asr r25
 894 0076 8795      		ror r24
 895 0078 9595      		asr r25
 896 007a 8795      		ror r24
 897 007c 8452      		subi r24,36
 898 007e 9F4F      		sbci r25,-1
 899 0080 9093 0000 		sts Consigne+1,r25
 900 0084 8093 0000 		sts Consigne,r24
 299:main.c        ****                 snprintf((char*)line1,16,"Set : %i C         ",Consigne);
 901               		.loc 1 299 0
 902 0088 9F93      		push r25
 903 008a 8F93      		push r24
 904 008c 3F92      		push r3
 905 008e 2F92      		push r2
 906 0090 1F92      		push __zero_reg__
 907 0092 1F93      		push r17
 908 0094 20E0      		ldi r18,lo8(line1)
 909 0096 30E0      		ldi r19,hi8(line1)
 910 0098 3F93      		push r19
 911 009a 2F93      		push r18
 912 009c 0E94 0000 		call snprintf
 913               	.LVL50:
 300:main.c        ****                 if(enc_switch_state()){
 914               		.loc 1 300 0
 915 00a0 0E94 0000 		call enc_switch_state
 916               	.LVL51:
 917 00a4 0FB6      		in __tmp_reg__,__SREG__
 918 00a6 F894      		cli
 919 00a8 DEBF      		out __SP_H__,r29
 920 00aa 0FBE      		out __SREG__,__tmp_reg__
 921 00ac CDBF      		out __SP_L__,r28
 922 00ae 8823      		tst r24
 923 00b0 01F4      		brne .+2
 924 00b2 00C0      		rjmp .L45
 925               	.L60:
 302:main.c        ****                     while(enc_switch_state());
 926               		.loc 1 302 0
 927 00b4 0E94 0000 		call enc_switch_state
 928               	.LVL52:
 929 00b8 8111      		cpse r24,__zero_reg__
 930 00ba 00C0      		rjmp .L60
 931               	.LVL53:
 932               	.LBB10:
 933               	.LBB11:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 934               		.loc 2 164 0
 935 00bc FFEF      		ldi r31,lo8(1599999)
 936 00be 29E6      		ldi r18,hi8(1599999)
 937 00c0 38E1      		ldi r19,hlo8(1599999)
 938 00c2 F150      		1: subi r31,1
 939 00c4 2040      		sbci r18,0
 940 00c6 3040      		sbci r19,0
 941 00c8 01F4      		brne 1b
 942 00ca 00C0      		rjmp .
 943 00cc 0000      		nop
 944 00ce 00C0      		rjmp .L47
 945               	.L48:
 946               	.LBE11:
 947               	.LBE10:
 948               		.loc 1 305 0
 949 00d0 0093 0000 		sts flag_change_consigne,r16
 306:main.c        ****                         update_screen();
 950               		.loc 1 306 0
 951 00d4 0E94 0000 		call update_screen
 952               	.LVL54:
 307:main.c        ****                         Consigne = DEFAULT_TEMP + (get_counts()>>2);
 953               		.loc 1 307 0
 954 00d8 0E94 0000 		call get_counts
 955               	.LVL55:
 956 00dc 9595      		asr r25
 957 00de 8795      		ror r24
 958 00e0 9595      		asr r25
 959 00e2 8795      		ror r24
 960 00e4 8452      		subi r24,36
 961 00e6 9F4F      		sbci r25,-1
 962 00e8 9093 0000 		sts Consigne+1,r25
 963 00ec 8093 0000 		sts Consigne,r24
 308:main.c        ****                         snprintf((char*)line1,16,"Set : %i C         ",Consigne);
 964               		.loc 1 308 0
 965 00f0 9F93      		push r25
 966 00f2 8F93      		push r24
 967 00f4 3F92      		push r3
 968 00f6 2F92      		push r2
 969 00f8 1F92      		push __zero_reg__
 970 00fa 1F93      		push r17
 971 00fc 40E0      		ldi r20,lo8(line1)
 972 00fe 50E0      		ldi r21,hi8(line1)
 973 0100 5F93      		push r21
 974 0102 4F93      		push r20
 975 0104 0E94 0000 		call snprintf
 976               	.LVL56:
 309:main.c        ****                         printf("[%s]\n\r",line1);
 977               		.loc 1 309 0
 978 0108 E0E0      		ldi r30,lo8(line1)
 979 010a F0E0      		ldi r31,hi8(line1)
 980 010c FF93      		push r31
 981 010e EF93      		push r30
 982 0110 40E0      		ldi r20,lo8(.LC2)
 983 0112 50E0      		ldi r21,hi8(.LC2)
 984 0114 5F93      		push r21
 985 0116 4F93      		push r20
 986 0118 0E94 0000 		call printf
 987               	.LVL57:
 988 011c 0FB6      		in __tmp_reg__,__SREG__
 989 011e F894      		cli
 990 0120 DEBF      		out __SP_H__,r29
 991 0122 0FBE      		out __SREG__,__tmp_reg__
 992 0124 CDBF      		out __SP_L__,r28
 993               	.L47:
 304:main.c        ****                     while(!enc_switch_state()){
 994               		.loc 1 304 0 discriminator 1
 995 0126 0E94 0000 		call enc_switch_state
 996               	.LVL58:
 997 012a 8823      		tst r24
 998 012c 01F0      		breq .L48
 999               	.LVL59:
 1000               	.LBB12:
 1001               	.LBB13:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1002               		.loc 2 164 0
 1003 012e FFEF      		ldi r31,lo8(1599999)
 1004 0130 29E6      		ldi r18,hi8(1599999)
 1005 0132 38E1      		ldi r19,hlo8(1599999)
 1006 0134 F150      		1: subi r31,1
 1007 0136 2040      		sbci r18,0
 1008 0138 3040      		sbci r19,0
 1009 013a 01F4      		brne 1b
 1010 013c 00C0      		rjmp .
 1011 013e 0000      		nop
 1012               	.LVL60:
 1013               	.L45:
 1014               	.LBE13:
 1015               	.LBE12:
 310:main.c        ****                     }
 311:main.c        ****                     _delay_ms(500);
 312:main.c        ****                 }
 313:main.c        ****                 flag_change_consigne = 0;
 1016               		.loc 1 313 0
 1017 0140 1092 0000 		sts flag_change_consigne,__zero_reg__
 314:main.c        ****                 state = Process_Commmand;
 1018               		.loc 1 314 0
 1019 0144 0093 0000 		sts state,r16
 315:main.c        ****                 break;
 1020               		.loc 1 315 0
 1021 0148 00C0      		rjmp .L63
 1022               	.L43:
 316:main.c        ****             case Process_Commmand:
 317:main.c        ****                 snprintf((char*)line1,16,"Temp %i C         ",Consigne);
 1023               		.loc 1 317 0
 1024 014a 8091 0000 		lds r24,Consigne+1
 1025 014e 8F93      		push r24
 1026 0150 8091 0000 		lds r24,Consigne
 1027 0154 8F93      		push r24
 1028 0156 40E0      		ldi r20,lo8(.LC3)
 1029 0158 50E0      		ldi r21,hi8(.LC3)
 1030 015a 5F93      		push r21
 1031 015c 4F93      		push r20
 1032 015e 1F92      		push __zero_reg__
 1033 0160 1F93      		push r17
 1034 0162 E0E0      		ldi r30,lo8(line1)
 1035 0164 F0E0      		ldi r31,hi8(line1)
 1036 0166 FF93      		push r31
 1037 0168 EF93      		push r30
 1038 016a 0E94 0000 		call snprintf
 1039               	.LVL61:
 318:main.c        ****                 update_screen();
 1040               		.loc 1 318 0
 1041 016e 0E94 0000 		call update_screen
 1042               	.LVL62:
 319:main.c        ****                 new_time = millis();
 1043               		.loc 1 319 0
 1044 0172 0E94 0000 		call millis
 1045               	.LVL63:
 1046 0176 0E94 0000 		call __fixsfsi
 1047               	.LVL64:
 1048 017a 6B01      		movw r12,r22
 1049 017c 7C01      		movw r14,r24
 1050 017e 6093 0000 		sts new_time,r22
 1051 0182 7093 0000 		sts new_time+1,r23
 1052 0186 8093 0000 		sts new_time+2,r24
 1053 018a 9093 0000 		sts new_time+3,r25
 320:main.c        ****                 dt       = new_time - old_time; 
 1054               		.loc 1 320 0
 1055 018e 8091 0000 		lds r24,old_time
 1056 0192 9091 0000 		lds r25,old_time+1
 1057 0196 A091 0000 		lds r26,old_time+2
 1058 019a B091 0000 		lds r27,old_time+3
 1059 019e A701      		movw r20,r14
 1060 01a0 9601      		movw r18,r12
 1061 01a2 281B      		sub r18,r24
 1062 01a4 390B      		sbc r19,r25
 1063 01a6 4A0B      		sbc r20,r26
 1064 01a8 5B0B      		sbc r21,r27
 1065 01aa CA01      		movw r24,r20
 1066 01ac B901      		movw r22,r18
 1067 01ae 0E94 0000 		call __floatsisf
 1068               	.LVL65:
 1069 01b2 6093 0000 		sts dt,r22
 1070 01b6 7093 0000 		sts dt+1,r23
 1071 01ba 8093 0000 		sts dt+2,r24
 1072 01be 9093 0000 		sts dt+3,r25
 321:main.c        ****                 old_time = new_time;
 1073               		.loc 1 321 0
 1074 01c2 C092 0000 		sts old_time,r12
 1075 01c6 D092 0000 		sts old_time+1,r13
 1076 01ca E092 0000 		sts old_time+2,r14
 1077 01ce F092 0000 		sts old_time+3,r15
 322:main.c        ****                 // Update display content
 323:main.c        ****                 tempp = get_temp();
 1078               		.loc 1 323 0
 1079 01d2 0E94 0000 		call get_temp
 1080               	.LVL66:
 1081 01d6 6B01      		movw r12,r22
 1082 01d8 7C01      		movw r14,r24
 1083               	.LVL67:
 324:main.c        ****                 snprintf((char*)line2,16," %i C             ",(int)tempp);
 1084               		.loc 1 324 0
 1085 01da 0E94 0000 		call __fixsfsi
 1086               	.LVL68:
 1087 01de 7F93      		push r23
 1088 01e0 6F93      		push r22
 1089 01e2 40E0      		ldi r20,lo8(.LC4)
 1090 01e4 50E0      		ldi r21,hi8(.LC4)
 1091 01e6 5F93      		push r21
 1092 01e8 4F93      		push r20
 1093 01ea 1F92      		push __zero_reg__
 1094 01ec 1F93      		push r17
 1095 01ee E0E0      		ldi r30,lo8(line2)
 1096 01f0 F0E0      		ldi r31,hi8(line2)
 1097 01f2 FF93      		push r31
 1098 01f4 EF93      		push r30
 1099 01f6 0E94 0000 		call snprintf
 1100               	.LVL69:
 325:main.c        ****                 if(tempp< 0.0){
 1101               		.loc 1 325 0
 1102 01fa 0FB6      		in __tmp_reg__,__SREG__
 1103 01fc F894      		cli
 1104 01fe DEBF      		out __SP_H__,r29
 1105 0200 0FBE      		out __SREG__,__tmp_reg__
 1106 0202 CDBF      		out __SP_L__,r28
 1107 0204 20E0      		ldi r18,0
 1108 0206 30E0      		ldi r19,0
 1109 0208 A901      		movw r20,r18
 1110 020a C701      		movw r24,r14
 1111 020c B601      		movw r22,r12
 1112 020e 0E94 0000 		call __ltsf2
 1113               	.LVL70:
 1114 0212 87FF      		sbrs r24,7
 1115 0214 00C0      		rjmp .L64
 326:main.c        ****                     snprintf((char*)line2,16,"No Iron               ");
 1116               		.loc 1 326 0
 1117 0216 80E0      		ldi r24,lo8(.LC5)
 1118 0218 90E0      		ldi r25,hi8(.LC5)
 1119 021a 9F93      		push r25
 1120 021c 8F93      		push r24
 1121 021e 1F92      		push __zero_reg__
 1122 0220 1F93      		push r17
 1123 0222 80E0      		ldi r24,lo8(line2)
 1124 0224 90E0      		ldi r25,hi8(line2)
 1125 0226 9F93      		push r25
 1126 0228 8F93      		push r24
 1127 022a 0E94 0000 		call snprintf
 1128               	.LVL71:
 327:main.c        ****                     update_screen();
 1129               		.loc 1 327 0
 1130 022e 0E94 0000 		call update_screen
 1131               	.LVL72:
 1132 0232 0F90      		pop __tmp_reg__
 1133 0234 0F90      		pop __tmp_reg__
 1134 0236 0F90      		pop __tmp_reg__
 1135 0238 0F90      		pop __tmp_reg__
 1136 023a 0F90      		pop __tmp_reg__
 1137 023c 0F90      		pop __tmp_reg__
 328:main.c        ****                     flag_no_iron = 1;
 1138               		.loc 1 328 0
 1139 023e F1E0      		ldi r31,lo8(1)
 1140 0240 F983      		std Y+1,r31
 1141 0242 00C0      		rjmp .L50
 1142               	.LVL73:
 1143               	.L64:
 329:main.c        ****                 }
 330:main.c        ****                 else{
 331:main.c        ****                     flag_no_iron = 0;
 1144               		.loc 1 331 0
 1145 0244 1982      		std Y+1,__zero_reg__
 1146               	.L50:
 1147               	.LVL74:
 332:main.c        ****                 }
 333:main.c        ****                 last_display_update_ms = new_time;
 1148               		.loc 1 333 0
 1149 0246 8091 0000 		lds r24,new_time
 1150 024a 9091 0000 		lds r25,new_time+1
 1151 024e A091 0000 		lds r26,new_time+2
 1152 0252 B091 0000 		lds r27,new_time+3
 1153 0256 8093 0000 		sts last_display_update_ms,r24
 1154 025a 9093 0000 		sts last_display_update_ms+1,r25
 1155 025e A093 0000 		sts last_display_update_ms+2,r26
 1156 0262 B093 0000 		sts last_display_update_ms+3,r27
 334:main.c        **** 
 335:main.c        ****                 new_error = Consigne - tempp; // Process new error
 1157               		.loc 1 335 0
 1158 0266 6091 0000 		lds r22,Consigne
 1159 026a 7091 0000 		lds r23,Consigne+1
 1160 026e 80E0      		ldi r24,0
 1161 0270 90E0      		ldi r25,0
 1162 0272 0E94 0000 		call __floatunsisf
 1163               	.LVL75:
 1164 0276 A701      		movw r20,r14
 1165 0278 9601      		movw r18,r12
 1166 027a 0E94 0000 		call __subsf3
 1167               	.LVL76:
 1168 027e 6B01      		movw r12,r22
 1169               	.LVL77:
 1170 0280 7C01      		movw r14,r24
 1171 0282 862F      		mov r24,r22
 1172 0284 9D2D      		mov r25,r13
 1173 0286 AE2D      		mov r26,r14
 1174 0288 BF2D      		mov r27,r15
 1175 028a 8093 0000 		sts new_error,r24
 1176 028e 9093 0000 		sts new_error+1,r25
 1177 0292 A093 0000 		sts new_error+2,r26
 1178 0296 B093 0000 		sts new_error+3,r27
 336:main.c        ****                 derivative = (new_error-old_error)/(dt/1000);
 1179               		.loc 1 336 0
 1180 029a 20E0      		ldi r18,0
 1181 029c 30E0      		ldi r19,0
 1182 029e 4AE7      		ldi r20,lo8(122)
 1183 02a0 54E4      		ldi r21,lo8(68)
 1184 02a2 6091 0000 		lds r22,dt
 1185 02a6 7091 0000 		lds r23,dt+1
 1186 02aa 8091 0000 		lds r24,dt+2
 1187 02ae 9091 0000 		lds r25,dt+3
 1188 02b2 0E94 0000 		call __divsf3
 1189               	.LVL78:
 1190 02b6 762E      		mov r7,r22
 1191 02b8 872E      		mov r8,r23
 1192 02ba 982E      		mov r9,r24
 1193 02bc A92E      		mov r10,r25
 1194 02be 2091 0000 		lds r18,old_error
 1195 02c2 3091 0000 		lds r19,old_error+1
 1196 02c6 4091 0000 		lds r20,old_error+2
 1197 02ca 5091 0000 		lds r21,old_error+3
 1198 02ce 6C2D      		mov r22,r12
 1199 02d0 7D2D      		mov r23,r13
 1200 02d2 8E2D      		mov r24,r14
 1201 02d4 9F2D      		mov r25,r15
 1202 02d6 0E94 0000 		call __subsf3
 1203               	.LVL79:
 1204 02da 272D      		mov r18,r7
 1205 02dc 382D      		mov r19,r8
 1206 02de 492D      		mov r20,r9
 1207 02e0 5A2D      		mov r21,r10
 1208 02e2 0E94 0000 		call __divsf3
 1209               	.LVL80:
 1210 02e6 B62E      		mov r11,r22
 1211 02e8 472E      		mov r4,r23
 1212 02ea 582E      		mov r5,r24
 1213 02ec 692E      		mov r6,r25
 1214 02ee 862F      		mov r24,r22
 1215 02f0 942D      		mov r25,r4
 1216 02f2 A52D      		mov r26,r5
 1217 02f4 B62D      		mov r27,r6
 1218 02f6 8093 0000 		sts derivative,r24
 1219 02fa 9093 0000 		sts derivative+1,r25
 1220 02fe A093 0000 		sts derivative+2,r26
 1221 0302 B093 0000 		sts derivative+3,r27
 337:main.c        ****                 integral += new_error*(dt/1000);
 1222               		.loc 1 337 0
 1223 0306 272D      		mov r18,r7
 1224 0308 382D      		mov r19,r8
 1225 030a 492D      		mov r20,r9
 1226 030c 5A2D      		mov r21,r10
 1227 030e 6C2D      		mov r22,r12
 1228 0310 7D2D      		mov r23,r13
 1229 0312 8E2D      		mov r24,r14
 1230 0314 9F2D      		mov r25,r15
 1231 0316 0E94 0000 		call __mulsf3
 1232               	.LVL81:
 1233 031a 2091 0000 		lds r18,integral
 1234 031e 3091 0000 		lds r19,integral+1
 1235 0322 4091 0000 		lds r20,integral+2
 1236 0326 5091 0000 		lds r21,integral+3
 1237 032a 0E94 0000 		call __addsf3
 1238               	.LVL82:
 1239 032e 762E      		mov r7,r22
 1240 0330 872E      		mov r8,r23
 1241 0332 982E      		mov r9,r24
 1242 0334 A92E      		mov r10,r25
 1243 0336 862F      		mov r24,r22
 1244 0338 982D      		mov r25,r8
 1245 033a A92D      		mov r26,r9
 1246 033c BA2D      		mov r27,r10
 1247 033e 8093 0000 		sts integral,r24
 1248 0342 9093 0000 		sts integral+1,r25
 1249 0346 A093 0000 		sts integral+2,r26
 1250 034a B093 0000 		sts integral+3,r27
 338:main.c        **** 
 339:main.c        ****                 old_error = new_error;
 1251               		.loc 1 339 0
 1252 034e 8C2D      		mov r24,r12
 1253 0350 9D2D      		mov r25,r13
 1254 0352 AE2D      		mov r26,r14
 1255 0354 BF2D      		mov r27,r15
 1256 0356 8093 0000 		sts old_error,r24
 1257 035a 9093 0000 		sts old_error+1,r25
 1258 035e A093 0000 		sts old_error+2,r26
 1259 0362 B093 0000 		sts old_error+3,r27
 340:main.c        **** 
 341:main.c        ****                 /*KP = 0.09; Réglage OK mais pas hyper stable
 342:main.c        ****                   KD = -0.13;
 343:main.c        ****                   KI = 0.0026;*/
 344:main.c        **** 
 345:main.c        ****                 KP = 0.17;
 1260               		.loc 1 345 0
 1261 0366 8BE7      		ldi r24,lo8(123)
 1262 0368 94E1      		ldi r25,lo8(20)
 1263 036a AEE2      		ldi r26,lo8(46)
 1264 036c BEE3      		ldi r27,lo8(62)
 1265 036e 8093 0000 		sts KP,r24
 1266 0372 9093 0000 		sts KP+1,r25
 1267 0376 A093 0000 		sts KP+2,r26
 1268 037a B093 0000 		sts KP+3,r27
 346:main.c        ****                 KD = 0.0; // Rend instable le système mm avec petites valeurs
 1269               		.loc 1 346 0
 1270 037e 1092 0000 		sts KD,__zero_reg__
 1271 0382 1092 0000 		sts KD+1,__zero_reg__
 1272 0386 1092 0000 		sts KD+2,__zero_reg__
 1273 038a 1092 0000 		sts KD+3,__zero_reg__
 347:main.c        ****                 KI = 0.005;
 1274               		.loc 1 347 0
 1275 038e 8AE0      		ldi r24,lo8(10)
 1276 0390 97ED      		ldi r25,lo8(-41)
 1277 0392 A3EA      		ldi r26,lo8(-93)
 1278 0394 BBE3      		ldi r27,lo8(59)
 1279 0396 8093 0000 		sts KI,r24
 1280 039a 9093 0000 		sts KI+1,r25
 1281 039e A093 0000 		sts KI+2,r26
 1282 03a2 B093 0000 		sts KI+3,r27
 348:main.c        ****                 // SIMU : en 5sec à 90%, 10sec à 100%, pas de dépassement
 349:main.c        ****                 command = KP*new_error + KD*derivative + KI*integral;
 1283               		.loc 1 349 0
 1284 03a6 2BE7      		ldi r18,lo8(123)
 1285 03a8 34E1      		ldi r19,lo8(20)
 1286 03aa 4EE2      		ldi r20,lo8(46)
 1287 03ac 5EE3      		ldi r21,lo8(62)
 1288 03ae 6C2D      		mov r22,r12
 1289 03b0 7D2D      		mov r23,r13
 1290 03b2 8E2D      		mov r24,r14
 1291 03b4 9F2D      		mov r25,r15
 1292 03b6 0E94 0000 		call __mulsf3
 1293               	.LVL83:
 1294 03ba 6B01      		movw r12,r22
 1295 03bc 7C01      		movw r14,r24
 1296 03be 20E0      		ldi r18,0
 1297 03c0 30E0      		ldi r19,0
 1298 03c2 A901      		movw r20,r18
 1299 03c4 6B2D      		mov r22,r11
 1300 03c6 742D      		mov r23,r4
 1301 03c8 852D      		mov r24,r5
 1302 03ca 962D      		mov r25,r6
 1303 03cc 0E94 0000 		call __mulsf3
 1304               	.LVL84:
 1305 03d0 9B01      		movw r18,r22
 1306 03d2 AC01      		movw r20,r24
 1307 03d4 C701      		movw r24,r14
 1308 03d6 B601      		movw r22,r12
 1309 03d8 0E94 0000 		call __addsf3
 1310               	.LVL85:
 1311 03dc 6B01      		movw r12,r22
 1312 03de 7C01      		movw r14,r24
 1313 03e0 2AE0      		ldi r18,lo8(10)
 1314 03e2 37ED      		ldi r19,lo8(-41)
 1315 03e4 43EA      		ldi r20,lo8(-93)
 1316 03e6 5BE3      		ldi r21,lo8(59)
 1317 03e8 672D      		mov r22,r7
 1318 03ea 782D      		mov r23,r8
 1319 03ec 892D      		mov r24,r9
 1320 03ee 9A2D      		mov r25,r10
 1321 03f0 0E94 0000 		call __mulsf3
 1322               	.LVL86:
 1323 03f4 9B01      		movw r18,r22
 1324 03f6 AC01      		movw r20,r24
 1325 03f8 C701      		movw r24,r14
 1326 03fa B601      		movw r22,r12
 1327 03fc 0E94 0000 		call __addsf3
 1328               	.LVL87:
 1329 0400 6B01      		movw r12,r22
 1330 0402 7C01      		movw r14,r24
 1331 0404 862F      		mov r24,r22
 1332 0406 9D2D      		mov r25,r13
 1333 0408 AE2D      		mov r26,r14
 1334 040a BF2D      		mov r27,r15
 1335 040c 8093 0000 		sts command,r24
 1336 0410 9093 0000 		sts command+1,r25
 1337 0414 A093 0000 		sts command+2,r26
 1338 0418 B093 0000 		sts command+3,r27
 350:main.c        ****                 if((command >= 0.0) && !flag_no_iron){
 1339               		.loc 1 350 0
 1340 041c 20E0      		ldi r18,0
 1341 041e 30E0      		ldi r19,0
 1342 0420 A901      		movw r20,r18
 1343 0422 6C2D      		mov r22,r12
 1344 0424 7D2D      		mov r23,r13
 1345 0426 8E2D      		mov r24,r14
 1346 0428 9F2D      		mov r25,r15
 1347 042a 0E94 0000 		call __gesf2
 1348               	.LVL88:
 1349 042e 87FD      		sbrc r24,7
 1350 0430 00C0      		rjmp .L52
 1351               		.loc 1 350 0 is_stmt 0 discriminator 1
 1352 0432 2981      		ldd r18,Y+1
 1353 0434 2111      		cpse r18,__zero_reg__
 1354 0436 00C0      		rjmp .L52
 351:main.c        ****                     set_temp(command);
 1355               		.loc 1 351 0 is_stmt 1
 1356 0438 6C2D      		mov r22,r12
 1357 043a 7D2D      		mov r23,r13
 1358 043c 8E2D      		mov r24,r14
 1359 043e 9F2D      		mov r25,r15
 1360 0440 00C0      		rjmp .L65
 1361               	.L52:
 352:main.c        ****                 }
 353:main.c        ****                 else{
 354:main.c        ****                     set_temp(0.0);
 1362               		.loc 1 354 0
 1363 0442 60E0      		ldi r22,0
 1364 0444 70E0      		ldi r23,0
 1365 0446 CB01      		movw r24,r22
 1366               	.L65:
 1367 0448 0E94 0000 		call set_temp
 1368               	.LVL89:
 355:main.c        ****                 }
 356:main.c        **** 
 357:main.c        ****                 state = Send_Log;
 1369               		.loc 1 357 0
 1370 044c 82E0      		ldi r24,lo8(2)
 1371 044e 8093 0000 		sts state,r24
 358:main.c        ****                 break;
 1372               		.loc 1 358 0
 1373 0452 00C0      		rjmp .L63
 1374               	.LVL90:
 1375               	.L44:
 359:main.c        ****             case Send_Log:
 360:main.c        ****                 state = Update_Consigne;
 1376               		.loc 1 360 0
 1377 0454 1092 0000 		sts state,__zero_reg__
 361:main.c        ****                 break;
 1378               		.loc 1 361 0
 1379 0458 00C0      		rjmp .L63
 1380               	.LFE25:
 1382               		.comm	time,4,1
 1383               	.global	last_display_update_ms
 1384               		.section .bss
 1387               	last_display_update_ms:
 1388 0000 0000 0000 		.zero	4
 1389               	.global	Consigne
 1390               		.data
 1393               	Consigne:
 1394 0000 DC00      		.word	220
 1395               	.global	line2
 1398               	line2:
 1399 0002 2020 2020 		.string	"               "
 1399      2020 2020 
 1399      2020 2020 
 1399      2020 2000 
 1400               	.global	line1
 1403               	line1:
 1404 0012 5374 6172 		.string	"Starting up ..."
 1404      7469 6E67 
 1404      2075 7020 
 1404      2E2E 2E00 
 1405               	.global	counts
 1406               		.section .bss
 1409               	counts:
 1410 0004 0000      		.zero	2
 1411               	.global	flag_change_consigne
 1414               	flag_change_consigne:
 1415 0006 00        		.zero	1
 1416               	.global	state
 1419               	state:
 1420 0007 00        		.zero	1
 1421               		.comm	old_time,4,1
 1422               		.comm	new_time,4,1
 1423               		.comm	command,4,1
 1424               		.comm	KD,4,1
 1425               		.comm	KI,4,1
 1426               		.comm	KP,4,1
 1427               		.comm	integral,4,1
 1428               		.comm	derivative,4,1
 1429               		.comm	new_error,4,1
 1430               		.comm	dt,4,1
 1431               		.comm	old_error,4,1
 1432               		.comm	sec,4,1
 1433               	.global	uart_output
 1434               		.data
 1437               	uart_output:
 1438 0022 0000 00   		.zero	3
 1439 0025 02        		.byte	2
 1440 0026 0000 0000 		.zero	4
 1441 002a 0000      		.word	gs(uart_putchar)
 1442 002c 0000      		.word	0
 1443 002e 0000      		.word	0
 1444               		.local	lpf_temp.1903
 1445               		.comm	lpf_temp.1903,4,1
 1748               	.Letext0:
 1749               		.file 3 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 1750               		.file 4 "/usr/lib/gcc/avr/4.7.2/include/stddef.h"
 1751               		.file 5 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdio.h"
 1752               		.file 6 "lcd.h"
 1753               		.file 7 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccYQRq6Z.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYQRq6Z.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYQRq6Z.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYQRq6Z.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYQRq6Z.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYQRq6Z.s:11     .text:0000000000000000 uart_putchar
     /tmp/ccYQRq6Z.s:36     .text:0000000000000012 adc_init
     /tmp/ccYQRq6Z.s:68     .text:0000000000000034 adc_read
     /tmp/ccYQRq6Z.s:101    .text:0000000000000064 uart_init
     /tmp/ccYQRq6Z.s:130    .text:0000000000000086 uart_getchar
     /tmp/ccYQRq6Z.s:151    .text:0000000000000094 timer1_init
     /tmp/ccYQRq6Z.s:204    .text:00000000000000ce timer0_init
     /tmp/ccYQRq6Z.s:244    .text:00000000000000ea __vector_16
                            *COM*:0000000000000004 sec
     /tmp/ccYQRq6Z.s:295    .text:0000000000000134 seconds
     /tmp/ccYQRq6Z.s:333    .text:000000000000015a millis
     /tmp/ccYQRq6Z.s:378    .text:000000000000018c set_temp
     /tmp/ccYQRq6Z.s:437    .text:00000000000001c2 get_temp
                             .bss:0000000000000008 lpf_temp.1903
     /tmp/ccYQRq6Z.s:610    .text:00000000000002de encoder_init
     /tmp/ccYQRq6Z.s:1409   .bss:0000000000000004 counts
     /tmp/ccYQRq6Z.s:645    .text:0000000000000300 enc_switch_state
     /tmp/ccYQRq6Z.s:665    .text:000000000000030e __vector_2
     /tmp/ccYQRq6Z.s:1414   .bss:0000000000000006 flag_change_consigne
     /tmp/ccYQRq6Z.s:715    .text:000000000000034c get_counts
     /tmp/ccYQRq6Z.s:744    .text:000000000000035a update_screen
     /tmp/ccYQRq6Z.s:1403   .data:0000000000000012 line1
     /tmp/ccYQRq6Z.s:1398   .data:0000000000000002 line2
     /tmp/ccYQRq6Z.s:805    .text.startup:0000000000000000 main
     /tmp/ccYQRq6Z.s:1437   .data:0000000000000022 uart_output
     /tmp/ccYQRq6Z.s:1393   .data:0000000000000000 Consigne
     /tmp/ccYQRq6Z.s:1419   .bss:0000000000000007 state
                            *COM*:0000000000000004 new_time
                            *COM*:0000000000000004 old_time
                            *COM*:0000000000000004 dt
     /tmp/ccYQRq6Z.s:1387   .bss:0000000000000000 last_display_update_ms
                            *COM*:0000000000000004 new_error
                            *COM*:0000000000000004 old_error
                            *COM*:0000000000000004 derivative
                            *COM*:0000000000000004 integral
                            *COM*:0000000000000004 KP
                            *COM*:0000000000000004 KD
                            *COM*:0000000000000004 KI
                            *COM*:0000000000000004 command
                            *COM*:0000000000000004 time

UNDEFINED SYMBOLS
__floatsisf
__mulsf3
__fixsfsi
__floatunsisf
__gtsf2
__subsf3
__addsf3
__divsf3
lcd_write_instruction_4d
lcd_write_string_4d
new_line
__ltsf2
__gesf2
__iob
lcd_init_4d
puts
snprintf
printf
__do_copy_data
__do_clear_bss
